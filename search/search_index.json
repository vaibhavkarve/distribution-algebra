{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A python package that implements an easy-to-use interface for random variables, statistical distributions, and their algebra.</p> <p> </p> <p>This Python package is brought to you by Vaibhav Karve.</p> <p><code>distribution-algebra</code> recognizes Normal, Lognormal, Beta and Poisson distributions. The package implements an interface to easily construct user-defined Univariate distributions as well Vectorized distributions.</p> <p>Additional features include: - A <code>plot</code> function for probability density/mass function plotting. - A <code>draw</code> function for drawing random samples of specified size from   a given distribution. - Addition and multiplication operations defined directly on   distributions:   - For example, the sum of two Normal (Poisson) distributions is     Normal (Poisson).   - The product of two Lognormal distributions is Lognormal.   - The sum of two arbitrary univariate distributions is expressed as     a Vectorized distribution.</p> <p></p> <p>This package is written in Python v3.10, and is available for installation from PyPI under the GNU-GPL-v3.0 license.</p>"},{"location":"#installation-and-usage","title":"Installation and usage","text":"<p>To get started on using this package,</p> <ol> <li>Install Python 3.10 or higher.</li> <li><code>python3.10 -m pip install distribution-algebra</code></li> <li>Use it in a python script (or interactive REPL)</li> </ol> Example showing addition of two Normal distributions<pre><code>from distribution_algebra import Normal  # (1)!\n\nx: Normal = Normal(mean=1.0, var=9.0)\ny: Normal = Normal(mean=1.0, var=16.0)\n\nassert x + y == Normal(mean=2.0, var=25.0)\n</code></pre> <ol> <li>You can similarly import other distributions as <code>from distribution_algebra import Normal, Beta, Lognormal, Beta4, Poisson</code>.</li> </ol>"},{"location":"__main__/","title":"main","text":""},{"location":"algebra/","title":"algebra","text":"<p>This module defines the commutative algebra structure of probability distributions.</p> <p>We define an <code>Algebra</code> class for enforcing the requisite structure via abstract-method definitions for left-operators. Right-operators for each left-operator is added on via <code>setattr</code> on the Algebra class (see function <code>define_right_operators_for_Algebra_class</code>).</p>"},{"location":"algebra/#distribution_algebra.algebra.Algebra","title":"Algebra","text":"<p>An abstract class for enforcing the definition of operations we care about.</p> <p>We specify left-operators as abstract methods in this class. Once the class is defined, we define the right-operators as being the swapped versions of their left-operators (see <code>Algebra_reverse_op</code> for details on how this is achieved).</p> Note <p>This class is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>class Algebra:\n    \"\"\"An abstract class for enforcing the definition of operations we care about.\n\n    We specify left-operators as abstract methods in this class. Once\n    the class is defined, we define the right-operators as being the\n    swapped versions of their left-operators (see `Algebra_reverse_op`\n    for details on how this is achieved).\n\n    Note:\n       This class is for internal use only.\n    \"\"\"\n\n    @abstractmethod\n    def __add__(self, other: Any) -&gt; Any:\n        \"\"\"An abstract left-addition method.\"\"\"\n        ...\n\n    @abstractmethod\n    def __sub__(self, other: Any) -&gt; Any:\n        \"\"\"An abstract left-subtraction method.\"\"\"\n        ...\n\n    @abstractmethod\n    def __mul__(self, other: Any) -&gt; Any:\n        \"\"\"An abstract left-multiplication method.\"\"\"\n        ...\n\n    @abstractmethod\n    def __truediv__(self, other: Any) -&gt; Any:\n        \"\"\"An abstract left-division method.\"\"\"\n        ...\n\n    @abstractmethod\n    def __pow__(self, other: Any) -&gt; Any:\n        \"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n        ...\n\n    @abstractmethod\n    def __neg__(self) -&gt; Any:\n        \"\"\"An abstract negation (additive inverse) method.\"\"\"\n        ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__add__","title":"__add__  <code>abstractmethod</code>","text":"<pre><code>__add__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-addition method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: Any) -&gt; Any:\n    \"\"\"An abstract left-addition method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__mul__","title":"__mul__  <code>abstractmethod</code>","text":"<pre><code>__mul__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-multiplication method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __mul__(self, other: Any) -&gt; Any:\n    \"\"\"An abstract left-multiplication method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__neg__","title":"__neg__  <code>abstractmethod</code>","text":"<pre><code>__neg__() -&gt; Any\n</code></pre> <p>An abstract negation (additive inverse) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __neg__(self) -&gt; Any:\n    \"\"\"An abstract negation (additive inverse) method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__pow__","title":"__pow__  <code>abstractmethod</code>","text":"<pre><code>__pow__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-power (or left-exponentiation) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __pow__(self, other: Any) -&gt; Any:\n    \"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__sub__","title":"__sub__  <code>abstractmethod</code>","text":"<pre><code>__sub__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-subtraction method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: Any) -&gt; Any:\n    \"\"\"An abstract left-subtraction method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__truediv__","title":"__truediv__  <code>abstractmethod</code>","text":"<pre><code>__truediv__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-division method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __truediv__(self, other: Any) -&gt; Any:\n    \"\"\"An abstract left-division method.\"\"\"\n    ...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra_reverse_op","title":"Algebra_reverse_op","text":"<pre><code>Algebra_reverse_op(op_name: str) -&gt; Callable[[Algebra, Any], Any]\n</code></pre> <p>Define the right-operator method, given a left-operator name in <code>op_name</code>.</p> Note <p>This function is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def Algebra_reverse_op(op_name: str) -&gt; Callable[[Algebra, Any], Any]:\n    \"\"\"Define the right-operator method, given a left-operator name in `op_name`.\n\n    Note:\n       This function is for internal use only.\n    \"\"\"\n\n    def self_op_other(self: Algebra, other: Any) -&gt; Any:\n        \"\"\"Reverse operation is just the operation acting on the arguments.\"\"\"\n        return getattr(self, op_name)(other)\n\n    return self_op_other\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.define_right_operators_for_Algebra_class","title":"define_right_operators_for_Algebra_class","text":"<pre><code>define_right_operators_for_Algebra_class() -&gt; None\n</code></pre> <p>Define a right-operator method for each of <code>Algebra</code>'s magic methods.</p> <p>We additionally mark each right-operator as being <code>final</code> in order to guard against a user over-riding them and possibly breaking symmetry with the left-operators.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def define_right_operators_for_Algebra_class() -&gt; None:\n    \"\"\"Define a right-operator method for each of `Algebra`'s magic methods.\n\n    We additionally mark each right-operator as being `final` in order\n    to guard against a user over-riding them and possibly breaking\n    symmetry with the left-operators.\n\n    \"\"\"\n    magic_left_operator_methods: list[str] = [\n        \"__add__\",\n        \"__mul__\",\n        \"__sub__\",\n        \"__truediv__\",\n        \"__pow__\",\n    ]\n\n    for magic_method in magic_left_operator_methods:\n        right_operator_name: str = \"__r\" + magic_method.removeprefix(\"__\")\n        setattr(Algebra, right_operator_name, final(Algebra_reverse_op(magic_method)))\n</code></pre>"},{"location":"beta/","title":"beta","text":""},{"location":"beta4/","title":"beta4","text":""},{"location":"binomial/","title":"Binomial","text":""},{"location":"config/","title":"config","text":""},{"location":"distribution/","title":"distribution","text":"<p>This module defines abstract classes for statistical distributions.</p> <p>We define 2 types of distributions. The first is <code>UnivariateDistribution</code>. Most named statistical distributions we learn about in a statistics course (Normal, Beta, Uniform, etc.) can be thought of as instances of <code>UnivariateDistribution</code>.</p> <p>Second, we define a statistical distribution whose parameter might not be known. Such a distribution is tracked by keeping around a really large sample. We name this a <code>VectorizedDistribution</code>. In many cases, working with vectorized distributions is easier since it allows us to apply algebraic operations to them.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution","title":"UnivariateDistribution","text":"<p>               Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A univariate probability distribution.</p> <p>All named distributions defined in this library are subclasses of <code>UnivariateDistribution</code>. This class can also be used by a user for defining new distributions (as subclasses) but beware that the class mandates lots of properties and methods be defined for each concrete subclass.</p> <p>Parameters:</p> Name Type Description Default <code>is_continuous</code> <p>used to track if the distribution is continuous or discrete.</p> required Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@attr.frozen(kw_only=True)\nclass UnivariateDistribution(Algebra, Generic[T_in]):\n    \"\"\"A univariate probability distribution.\n\n    All named distributions defined in this library are subclasses of\n    `UnivariateDistribution`. This class can also be used by a user for defining new\n    distributions (as subclasses) but beware that the class mandates\n    lots of properties and methods be defined for each concrete subclass.\n\n    Params:\n       is_continuous: used to track if the distribution is continuous or discrete.\n\n    Other Params: Implementation details\n       * If `is_continuous` is set to True, then `T_in` should be a \"continuous\" type like\n         `float` or `numpy.float64`. If it is set to False, then `T_in` should be a discrete\n         type like `int` or `numpy.int_`.\n       * We set `frozen=True` to enforce immutability of each subclass and each instance of\n         this class.\n       * We set `unsafe_hash=True` to make this class hashable (it is immutable\n         after all).\n    \"\"\"\n\n    @property\n    def is_continuous(self) -&gt; bool:\n        \"\"\"Return True if the distribution is continuous, else return False.\n\n        Continuity (or distcreteness) of the distribution is the\n        continuity (or discreteness) of its support space. This is\n        captured by the Generic type variable `T_in`. If the\n        distribution is continuous (like `Normal &lt;:\n        UnivariateDistribution[numpy.float64]`, the this property returns\n        True. If the distribution is discrete (like `Binomial &lt;:\n        UnivariateDistribution[numpy.int_]`, then this property is False.\n\n        \"\"\"\n        assert hasattr(self, \"__orig_bases__\")\n        T_in_at_runtime: type = get_args(self.__orig_bases__[0])[0]  # pyright: ignore\n        match T_in_at_runtime:\n            case np.int_ | np.int_:\n                return False\n            case np.float64:\n                return True\n            case _:\n                raise TypeError(f\"Found unsupported type {T_in_at_runtime}\")\n\n    @property\n    @abstractmethod\n    def median(self) -&gt; float:\n        \"\"\"Return the median value of the distribution if it is defined.\"\"\"\n\n    @property\n    @abstractmethod\n    def mode(self) -&gt; float:\n        \"\"\"Return the mode (most-liekely) value of the distribution if it is defined.\"\"\"\n\n    @property\n    @abstractmethod\n    def support(self) -&gt; tuple[T_in, T_in]:\n        \"\"\"Return the (min, max) range of the distribution's support interval.\n\n        In some cases, if one of the support ends is positive or\n        negative infinity, we use the closest value to infinity\n        expressible while using a constrained `T_in` type.\n\n        \"\"\"\n\n    @abstractmethod\n    def draw(self, size: int) -&gt; NDArray[T_in]:\n        \"\"\"Draw a random sample of given `size` from the distribution.\n\n        For efficiently drawing many random numbers from a\n        distribution with fixed parameters, it is recommended that\n        this method be used with the appropriate `size` instead of\n        drawing `size=1` samples inside a separate loop.\n\n        Note:\n           Not to be confused with `distribution_algebra.plotter.plot`\n           method which is used for plotting a distribution's graph.\n\n        Implementation detail:\n           This method should always use numpy's `default_rng` and its\n           associated methods for drawing random samples from various\n           distributions.\n\n        \"\"\"\n\n    def to_vectorized(self) -&gt; VectorizedDistribution[T_in]:\n        \"\"\"Convert to a `VectorizedDistribution`.\n\n        This method is called internally when we perform algebraic\n        operations on distributions whose closed-form expressions are\n        not known.\n\n        Note:\n           In most cases, if using `(x:\n           UnivariateDistribution).to_vectorized()` to create a\n           `VectorizedDistribution` instance, the instance's\n           `is_continuous` parameter is equal to `x.is_continuous`. In\n           other words, continuous (discrete) univariate distributions\n           give rise to continuous (discrete) vectorized\n           distributions.\n\n        \"\"\"\n        return VectorizedDistribution(  # type: ignore\n            sample=self.draw(size=Config.sample_size), is_continuous=self.is_continuous\n        )\n\n    @abstractmethod\n    def pdf(self, linspace: NDArray[T_in]) -&gt; NDArray[np.float64]:\n        \"\"\"Return the probability density (or mass) function's values at the given domain points.\n\n        Implementation detail:\n           This method usually uses scipy's statistical distribution's\n           probability density/mass functions.\n\n        In the case of continuous (or discrete) distributions, this\n        function accepts a parameter vector of points in\n        `numpy.float64` (or `numpy.int_`) space. While the function's\n        implementation does not put any constraints on the input\n        vector, the user can usually generate an appropriate input by\n        using `numpy.linspace` or `numpy.arange`.\n\n        \"\"\"\n\n    def __add__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-sum of a UnivatiateDistribution with any other type.\n\n        Types:\n           - `UnivariateDistribution + UnivariateDistribution`: the result is the sum of\n             the vectorized versions of the two distributions.\n           - `UnivariateDistribution + Any`: the left-parameter is vectorized and then\n             added to the right-parameter.\n\n        \"\"\"\n        match other:\n            case UnivariateDistribution():\n                return self.to_vectorized() + other.to_vectorized()\n            case _:\n                return self.to_vectorized() + other\n\n    def __mul__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-product of a UnivariateDistribution with any other type.\n\n        Types:\n           - `UnivariateDistribution * UnivariateDistribution`: the result is the product of\n             the vectorized versions of the two distributions.\n           - `UnivariateDistribution * Any`: the left-parameter is vectorized and then\n             multiplied by the right-parameter.\n        \"\"\"\n        match other:\n            case UnivariateDistribution():\n                return self.to_vectorized() * other.to_vectorized()\n            case _:\n                return self.to_vectorized() * other\n\n    def __sub__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-difference of a UnivariateDistribution with any other type.\n\n        Types:\n           - `UnivariateDistribution - UnivariateDistribution`: the result is the\n             difference of the vectorized versions of the two distributions.\n           - `UnivariateDistribution - Any`: the left-parameter is vectorized and then\n             the right-parameter is subtracted from it.\n        \"\"\"\n        match other:\n            case UnivariateDistribution():\n                return self.to_vectorized() - other.to_vectorized()\n            case _:\n                return self.to_vectorized() - other\n\n    def __truediv__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-division of a UnivariateDistribution with any other type.\n\n        Types:\n           - `UnivariateDistribution / UnivariateDistribution`: the result is the\n             ratio of the vectorized versions of the two distributions.\n           - `UnivariateDistribution / Any`: the left-parameter is vectorized and then\n             divided by the right-parameter.\n\n        \"\"\"\n        match other:\n            case UnivariateDistribution():\n                return self.to_vectorized() / other.to_vectorized()\n            case _:\n                return self.to_vectorized() / other\n\n    def __pow__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-power of a VectorDistribution with any other type.\n\n        Types:\n           - `UnivariateDistribution ** UnivariateDistribution`: the result is the\n              vectorized version of the first distribution raised to the power\n              of the two distributions.\n           - `UnivariateDistribution ** Any`: the left-parameter is vectorized and then\n             raised to the right-parameter.\n\n        \"\"\"\n        match other:\n            case UnivariateDistribution():\n                return self.to_vectorized() ** other.to_vectorized()\n            case _:\n                return self.to_vectorized() ** other\n\n    def __neg__(self) -&gt; Any:\n        return -self.to_vectorized()\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({vars(self)})\"\n\n    def __eq__(self, other: Any) -&gt; bool:\n        match other:\n            case UnivariateDistribution():\n                if not isinstance(other, type(self)):\n                    return False\n                if not vars(self).keys() == vars(other).keys():\n                    return False\n                return all(\n                    isclose(value, vars(other)[field], abs_tol=Config.abs_tol)\n                    for field, value in vars(self).items()\n                )\n            case _:\n                return NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.is_continuous","title":"is_continuous  <code>property</code>","text":"<pre><code>is_continuous: bool\n</code></pre> <p>Return True if the distribution is continuous, else return False.</p> <p>Continuity (or distcreteness) of the distribution is the continuity (or discreteness) of its support space. This is captured by the Generic type variable <code>T_in</code>. If the distribution is continuous (like <code>Normal &lt;: UnivariateDistribution[numpy.float64]</code>, the this property returns True. If the distribution is discrete (like <code>Binomial &lt;: UnivariateDistribution[numpy.int_]</code>, then this property is False.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.median","title":"median  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>median: float\n</code></pre> <p>Return the median value of the distribution if it is defined.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.mode","title":"mode  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>mode: float\n</code></pre> <p>Return the mode (most-liekely) value of the distribution if it is defined.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.support","title":"support  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>support: tuple[T_in, T_in]\n</code></pre> <p>Return the (min, max) range of the distribution's support interval.</p> <p>In some cases, if one of the support ends is positive or negative infinity, we use the closest value to infinity expressible while using a constrained <code>T_in</code> type.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-sum of a UnivatiateDistribution with any other type.</p> Types <ul> <li><code>UnivariateDistribution + UnivariateDistribution</code>: the result is the sum of   the vectorized versions of the two distributions.</li> <li><code>UnivariateDistribution + Any</code>: the left-parameter is vectorized and then   added to the right-parameter.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __add__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-sum of a UnivatiateDistribution with any other type.\n\n    Types:\n       - `UnivariateDistribution + UnivariateDistribution`: the result is the sum of\n         the vectorized versions of the two distributions.\n       - `UnivariateDistribution + Any`: the left-parameter is vectorized and then\n         added to the right-parameter.\n\n    \"\"\"\n    match other:\n        case UnivariateDistribution():\n            return self.to_vectorized() + other.to_vectorized()\n        case _:\n            return self.to_vectorized() + other\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-product of a UnivariateDistribution with any other type.</p> Types <ul> <li><code>UnivariateDistribution * UnivariateDistribution</code>: the result is the product of   the vectorized versions of the two distributions.</li> <li><code>UnivariateDistribution * Any</code>: the left-parameter is vectorized and then   multiplied by the right-parameter.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __mul__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-product of a UnivariateDistribution with any other type.\n\n    Types:\n       - `UnivariateDistribution * UnivariateDistribution`: the result is the product of\n         the vectorized versions of the two distributions.\n       - `UnivariateDistribution * Any`: the left-parameter is vectorized and then\n         multiplied by the right-parameter.\n    \"\"\"\n    match other:\n        case UnivariateDistribution():\n            return self.to_vectorized() * other.to_vectorized()\n        case _:\n            return self.to_vectorized() * other\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-power of a VectorDistribution with any other type.</p> Types <ul> <li><code>UnivariateDistribution ** UnivariateDistribution</code>: the result is the    vectorized version of the first distribution raised to the power    of the two distributions.</li> <li><code>UnivariateDistribution ** Any</code>: the left-parameter is vectorized and then   raised to the right-parameter.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __pow__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-power of a VectorDistribution with any other type.\n\n    Types:\n       - `UnivariateDistribution ** UnivariateDistribution`: the result is the\n          vectorized version of the first distribution raised to the power\n          of the two distributions.\n       - `UnivariateDistribution ** Any`: the left-parameter is vectorized and then\n         raised to the right-parameter.\n\n    \"\"\"\n    match other:\n        case UnivariateDistribution():\n            return self.to_vectorized() ** other.to_vectorized()\n        case _:\n            return self.to_vectorized() ** other\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-difference of a UnivariateDistribution with any other type.</p> Types <ul> <li><code>UnivariateDistribution - UnivariateDistribution</code>: the result is the   difference of the vectorized versions of the two distributions.</li> <li><code>UnivariateDistribution - Any</code>: the left-parameter is vectorized and then   the right-parameter is subtracted from it.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __sub__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-difference of a UnivariateDistribution with any other type.\n\n    Types:\n       - `UnivariateDistribution - UnivariateDistribution`: the result is the\n         difference of the vectorized versions of the two distributions.\n       - `UnivariateDistribution - Any`: the left-parameter is vectorized and then\n         the right-parameter is subtracted from it.\n    \"\"\"\n    match other:\n        case UnivariateDistribution():\n            return self.to_vectorized() - other.to_vectorized()\n        case _:\n            return self.to_vectorized() - other\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-division of a UnivariateDistribution with any other type.</p> Types <ul> <li><code>UnivariateDistribution / UnivariateDistribution</code>: the result is the   ratio of the vectorized versions of the two distributions.</li> <li><code>UnivariateDistribution / Any</code>: the left-parameter is vectorized and then   divided by the right-parameter.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-division of a UnivariateDistribution with any other type.\n\n    Types:\n       - `UnivariateDistribution / UnivariateDistribution`: the result is the\n         ratio of the vectorized versions of the two distributions.\n       - `UnivariateDistribution / Any`: the left-parameter is vectorized and then\n         divided by the right-parameter.\n\n    \"\"\"\n    match other:\n        case UnivariateDistribution():\n            return self.to_vectorized() / other.to_vectorized()\n        case _:\n            return self.to_vectorized() / other\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.draw","title":"draw  <code>abstractmethod</code>","text":"<pre><code>draw(size: int) -&gt; NDArray[T_in]\n</code></pre> <p>Draw a random sample of given <code>size</code> from the distribution.</p> <p>For efficiently drawing many random numbers from a distribution with fixed parameters, it is recommended that this method be used with the appropriate <code>size</code> instead of drawing <code>size=1</code> samples inside a separate loop.</p> Note <p>Not to be confused with <code>distribution_algebra.plotter.plot</code> method which is used for plotting a distribution's graph.</p> Implementation detail <p>This method should always use numpy's <code>default_rng</code> and its associated methods for drawing random samples from various distributions.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@abstractmethod\ndef draw(self, size: int) -&gt; NDArray[T_in]:\n    \"\"\"Draw a random sample of given `size` from the distribution.\n\n    For efficiently drawing many random numbers from a\n    distribution with fixed parameters, it is recommended that\n    this method be used with the appropriate `size` instead of\n    drawing `size=1` samples inside a separate loop.\n\n    Note:\n       Not to be confused with `distribution_algebra.plotter.plot`\n       method which is used for plotting a distribution's graph.\n\n    Implementation detail:\n       This method should always use numpy's `default_rng` and its\n       associated methods for drawing random samples from various\n       distributions.\n\n    \"\"\"\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.pdf","title":"pdf  <code>abstractmethod</code>","text":"<pre><code>pdf(linspace: NDArray[T_in]) -&gt; NDArray[np.float64]\n</code></pre> <p>Return the probability density (or mass) function's values at the given domain points.</p> Implementation detail <p>This method usually uses scipy's statistical distribution's probability density/mass functions.</p> <p>In the case of continuous (or discrete) distributions, this function accepts a parameter vector of points in <code>numpy.float64</code> (or <code>numpy.int_</code>) space. While the function's implementation does not put any constraints on the input vector, the user can usually generate an appropriate input by using <code>numpy.linspace</code> or <code>numpy.arange</code>.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@abstractmethod\ndef pdf(self, linspace: NDArray[T_in]) -&gt; NDArray[np.float64]:\n    \"\"\"Return the probability density (or mass) function's values at the given domain points.\n\n    Implementation detail:\n       This method usually uses scipy's statistical distribution's\n       probability density/mass functions.\n\n    In the case of continuous (or discrete) distributions, this\n    function accepts a parameter vector of points in\n    `numpy.float64` (or `numpy.int_`) space. While the function's\n    implementation does not put any constraints on the input\n    vector, the user can usually generate an appropriate input by\n    using `numpy.linspace` or `numpy.arange`.\n\n    \"\"\"\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.to_vectorized","title":"to_vectorized","text":"<pre><code>to_vectorized() -&gt; VectorizedDistribution[T_in]\n</code></pre> <p>Convert to a <code>VectorizedDistribution</code>.</p> <p>This method is called internally when we perform algebraic operations on distributions whose closed-form expressions are not known.</p> Note <p>In most cases, if using <code>(x: UnivariateDistribution).to_vectorized()</code> to create a <code>VectorizedDistribution</code> instance, the instance's <code>is_continuous</code> parameter is equal to <code>x.is_continuous</code>. In other words, continuous (discrete) univariate distributions give rise to continuous (discrete) vectorized distributions.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def to_vectorized(self) -&gt; VectorizedDistribution[T_in]:\n    \"\"\"Convert to a `VectorizedDistribution`.\n\n    This method is called internally when we perform algebraic\n    operations on distributions whose closed-form expressions are\n    not known.\n\n    Note:\n       In most cases, if using `(x:\n       UnivariateDistribution).to_vectorized()` to create a\n       `VectorizedDistribution` instance, the instance's\n       `is_continuous` parameter is equal to `x.is_continuous`. In\n       other words, continuous (discrete) univariate distributions\n       give rise to continuous (discrete) vectorized\n       distributions.\n\n    \"\"\"\n    return VectorizedDistribution(  # type: ignore\n        sample=self.draw(size=Config.sample_size), is_continuous=self.is_continuous\n    )\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution","title":"VectorizedDistribution","text":"<p>               Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A Vectorized form of a probability distribution.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <p>the sample-vector used in lieu of a closed-form expression for the distribution.</p> required <code>is_continuous</code> <p>used to track if the distribution is continuous or discrete.</p> required Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@attr.frozen(kw_only=True)\nclass VectorizedDistribution(Algebra, Generic[T_in]):\n    \"\"\"A Vectorized form of a probability distribution.\n\n    Params:\n       sample: the sample-vector used in lieu of a closed-form expression for\n          the distribution.\n       is_continuous: used to track if the distribution is continuous or discrete.\n\n    Other Params: Implementation details\n       * We use `attr.frozen` in this definition because it supports validation and\n         immutability.\n       * We use `attr.frozen` to enforce immutability of each instance of this class.\n         To modify the class or its sample-attribute, the user must define a new\n         instance (or use `attr.evolve`) instead of modifying an existing one.\n       * `sample` is chosen to be a numpy array to leverage the fast, vectorized\n         operations enabled by numpy's C API.\n\n    \"\"\"\n\n    sample: NDArray[T_in] = attr.field(eq=attr.cmp_using(eq=np.array_equal))  # type: ignore\n    is_continuous: bool = attr.field(repr=False)\n\n    @is_continuous.validator  # type: ignore\n    def check_is_continuous(\n        self, _: Literal[\"is_continuous\"], is_continuous_value: bool\n    ) -&gt; None:\n        match self.sample.dtype:\n            case np.int_:\n                assert not is_continuous_value\n            case np.float64:\n                assert is_continuous_value\n            case _:\n                raise TypeError(\n                    f\"Encountered unknown type {self.sample.dtype} in VectorizedDistribution.\"\n                )\n\n    @property\n    def mean(self) -&gt; np.float64:\n        \"\"\"Mean of the distribution, defined as the mean of the sample.\n\n        Returns:\n           mean of the distribution, defined as the mean of the sample.\n        \"\"\"\n        return np.float64(self.sample.mean())\n\n    @property\n    def var(self) -&gt; np.float64:\n        \"\"\"Variance of the distribution, defined as the variance of the sample.\n\n        Returns:\n           variance of the distribution, defined as the variance of the sample.\n        \"\"\"\n        return np.float64(self.sample.var())\n\n    def __add__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-sum of a VectorDistribution with any other type.\n\n        Types:\n           - `VectorizedDistribution + VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise sum\n             of the sample parameters of the summands.\n           - `VectorizedDistribution + Number`: the result is a vectorized-distribution\n             whose sample values have been shifted.\n        \"\"\"\n        match other:\n            case VectorizedDistribution():\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample + other.sample,\n                    is_continuous=self.is_continuous or other.is_continuous,\n                )\n            case float() | int():\n                return VectorizedDistribution(\n                    sample=self.sample + other,  # type: ignore\n                    is_continuous=self.is_continuous or isinstance(other, float),\n                )\n            case _:\n                return NotImplemented\n\n    def __mul__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-product of a VectorDistribution with any other type.\n\n        Types:\n           - `VectorizedDistribution * VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise product\n             of the sample parameters of the multiplicands.\n           - `VectorizedDistribution * Number`: the result is a vectorized-distribution\n             whose sample values have been scaled.\n        \"\"\"\n        match other:\n            case VectorizedDistribution():\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample * other.sample,\n                    is_continuous=self.is_continuous or other.is_continuous,\n                )\n            case float() | int():\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample * other,\n                    is_continuous=self.is_continuous or isinstance(other, float),\n                )\n            case _:\n                return NotImplemented\n\n    def __sub__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-difference of a VectorDistribution with any other type.\n\n        Types:\n           - `VectorizedDistribution - VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise difference\n             of the sample parameters of the arguments.\n           - `VectorizedDistribution - Number`: the result is a vectorized-distribution\n             whose sample values have been shifted.\n        \"\"\"\n        match other:\n            case VectorizedDistribution():\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample - other.sample,\n                    is_continuous=self.is_continuous or other.is_continuous,\n                )\n            case float() | int():\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample - other,\n                    is_continuous=self.is_continuous or isinstance(other, float),\n                )\n            case _:\n                return NotImplemented\n\n    def __pow__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-power of a VectorDistribution with any other type.\n\n        Types:\n           - `VectorizedDistribution ** VectorizedDistribution`: the result is also a\n             vectorized-distrubution. Result's i'th sample entry is\n             `self.sample[i] ** other.sample[i]`.\n           - `VectorizedDistribution - Number`: the result is a vectorized-distribution.\n             Result's i'th sample entry is `self.sample[i] ** other`.\n\n        Warns:\n           - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistrion | Number)`\n             would result in raising a negative number to any power.\n           - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistribution | Number)`\n             would result in a `0 ** 0` computation.\n        \"\"\"\n        match other:\n            case VectorizedDistribution():\n                if (self.sample &lt; 0).any():\n                    warnings.warn(\"All entries in base array should be positive.\")\n                if (other.sample == 0).any() and (self.sample == 0).any():\n                    warnings.warn(\n                        \"Attempting to compute 0**0 during (base array)**(other array) computation.\"\n                    )\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample**other.sample,\n                    is_continuous=self.is_continuous or other.is_continuous,\n                )\n            case float() | int():\n                if (self.sample &lt; 0).any():\n                    warnings.warn(\"All entries in base array should be positive.\")\n                if not other and (self.sample == 0).any():\n                    warnings.warn(\n                        \"Attempting to compute 0**0 during (base array)**other computation.\"\n                    )\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample**other,\n                    is_continuous=self.is_continuous or isinstance(other, float),\n                )\n            case _:\n                return NotImplemented\n\n    def __truediv__(self, other: Any) -&gt; Any:\n        \"\"\"Return the left-division of a VectorDistribution with any other type.\n\n        Types:\n           - `VectorizedDistribution / VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose sample parameter is the element-wise ratio\n             of the sample parameters of the arguments.\n           - `VectorizedDistribution / Number`: the result is a vectorized-distribution\n             whose sample parameter has been scaled down.\n\n        Warns:\n           - UserWarning: if computing `VectorizedDistribution / (VectorizedDistrion | Number)`\n             would result in a `x / 0` calculation, for any x.\n        \"\"\"\n        match other:\n            case VectorizedDistribution():\n                if (other.sample == 0).any():\n                    warnings.warn(\n                        \"All entries in denominator array should be non-zero.\"\n                    )\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample / other.sample, is_continuous=True\n                )\n            case float() | int():\n                if other == 0:\n                    warnings.warn(\n                        \"Attempting to divide a vectorized distribution by zero.\"\n                    )\n                return VectorizedDistribution(  # type: ignore\n                    sample=self.sample / other, is_continuous=True\n                )\n            case _:\n                return NotImplemented\n\n    def __neg__(self) -&gt; Any:\n        \"\"\"Return the negative of a VectorizedDistribution.\n\n        Returns:\n           (VectorizedDistribution): A VectorizedDistribution whose sample entries are the\n              negative of the original's.\n        \"\"\"\n        return VectorizedDistribution(sample=-self.sample,\n                                      is_continuous=self.is_continuous)  # type: ignore\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.mean","title":"mean  <code>property</code>","text":"<pre><code>mean: float64\n</code></pre> <p>Mean of the distribution, defined as the mean of the sample.</p> <p>Returns:</p> Type Description <code>float64</code> <p>mean of the distribution, defined as the mean of the sample.</p>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.var","title":"var  <code>property</code>","text":"<pre><code>var: float64\n</code></pre> <p>Variance of the distribution, defined as the variance of the sample.</p> <p>Returns:</p> Type Description <code>float64</code> <p>variance of the distribution, defined as the variance of the sample.</p>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-sum of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution + VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise sum   of the sample parameters of the summands.</li> <li><code>VectorizedDistribution + Number</code>: the result is a vectorized-distribution   whose sample values have been shifted.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __add__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-sum of a VectorDistribution with any other type.\n\n    Types:\n       - `VectorizedDistribution + VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise sum\n         of the sample parameters of the summands.\n       - `VectorizedDistribution + Number`: the result is a vectorized-distribution\n         whose sample values have been shifted.\n    \"\"\"\n    match other:\n        case VectorizedDistribution():\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample + other.sample,\n                is_continuous=self.is_continuous or other.is_continuous,\n            )\n        case float() | int():\n            return VectorizedDistribution(\n                sample=self.sample + other,  # type: ignore\n                is_continuous=self.is_continuous or isinstance(other, float),\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-product of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution * VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise product   of the sample parameters of the multiplicands.</li> <li><code>VectorizedDistribution * Number</code>: the result is a vectorized-distribution   whose sample values have been scaled.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __mul__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-product of a VectorDistribution with any other type.\n\n    Types:\n       - `VectorizedDistribution * VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise product\n         of the sample parameters of the multiplicands.\n       - `VectorizedDistribution * Number`: the result is a vectorized-distribution\n         whose sample values have been scaled.\n    \"\"\"\n    match other:\n        case VectorizedDistribution():\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample * other.sample,\n                is_continuous=self.is_continuous or other.is_continuous,\n            )\n        case float() | int():\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample * other,\n                is_continuous=self.is_continuous or isinstance(other, float),\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Any\n</code></pre> <p>Return the negative of a VectorizedDistribution.</p> <p>Returns:</p> Type Description <code>VectorizedDistribution</code> <p>A VectorizedDistribution whose sample entries are the negative of the original's.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __neg__(self) -&gt; Any:\n    \"\"\"Return the negative of a VectorizedDistribution.\n\n    Returns:\n       (VectorizedDistribution): A VectorizedDistribution whose sample entries are the\n          negative of the original's.\n    \"\"\"\n    return VectorizedDistribution(sample=-self.sample,\n                                  is_continuous=self.is_continuous)  # type: ignore\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-power of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution ** VectorizedDistribution</code>: the result is also a   vectorized-distrubution. Result's i'th sample entry is   <code>self.sample[i] ** other.sample[i]</code>.</li> <li><code>VectorizedDistribution - Number</code>: the result is a vectorized-distribution.   Result's i'th sample entry is <code>self.sample[i] ** other</code>.</li> </ul> <p>Warns:</p> Type Description <code>- UserWarning</code> <p>if computing <code>VectorizedDistribution ** (VectorizedDistrion | Number)</code> would result in raising a negative number to any power.</p> <code>- UserWarning</code> <p>if computing <code>VectorizedDistribution ** (VectorizedDistribution | Number)</code> would result in a <code>0 ** 0</code> computation.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __pow__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-power of a VectorDistribution with any other type.\n\n    Types:\n       - `VectorizedDistribution ** VectorizedDistribution`: the result is also a\n         vectorized-distrubution. Result's i'th sample entry is\n         `self.sample[i] ** other.sample[i]`.\n       - `VectorizedDistribution - Number`: the result is a vectorized-distribution.\n         Result's i'th sample entry is `self.sample[i] ** other`.\n\n    Warns:\n       - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistrion | Number)`\n         would result in raising a negative number to any power.\n       - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistribution | Number)`\n         would result in a `0 ** 0` computation.\n    \"\"\"\n    match other:\n        case VectorizedDistribution():\n            if (self.sample &lt; 0).any():\n                warnings.warn(\"All entries in base array should be positive.\")\n            if (other.sample == 0).any() and (self.sample == 0).any():\n                warnings.warn(\n                    \"Attempting to compute 0**0 during (base array)**(other array) computation.\"\n                )\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample**other.sample,\n                is_continuous=self.is_continuous or other.is_continuous,\n            )\n        case float() | int():\n            if (self.sample &lt; 0).any():\n                warnings.warn(\"All entries in base array should be positive.\")\n            if not other and (self.sample == 0).any():\n                warnings.warn(\n                    \"Attempting to compute 0**0 during (base array)**other computation.\"\n                )\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample**other,\n                is_continuous=self.is_continuous or isinstance(other, float),\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-difference of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution - VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise difference   of the sample parameters of the arguments.</li> <li><code>VectorizedDistribution - Number</code>: the result is a vectorized-distribution   whose sample values have been shifted.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __sub__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-difference of a VectorDistribution with any other type.\n\n    Types:\n       - `VectorizedDistribution - VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise difference\n         of the sample parameters of the arguments.\n       - `VectorizedDistribution - Number`: the result is a vectorized-distribution\n         whose sample values have been shifted.\n    \"\"\"\n    match other:\n        case VectorizedDistribution():\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample - other.sample,\n                is_continuous=self.is_continuous or other.is_continuous,\n            )\n        case float() | int():\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample - other,\n                is_continuous=self.is_continuous or isinstance(other, float),\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-division of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution / VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose sample parameter is the element-wise ratio   of the sample parameters of the arguments.</li> <li><code>VectorizedDistribution / Number</code>: the result is a vectorized-distribution   whose sample parameter has been scaled down.</li> </ul> <p>Warns:</p> Type Description <code>- UserWarning</code> <p>if computing <code>VectorizedDistribution / (VectorizedDistrion | Number)</code> would result in a <code>x / 0</code> calculation, for any x.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; Any:\n    \"\"\"Return the left-division of a VectorDistribution with any other type.\n\n    Types:\n       - `VectorizedDistribution / VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose sample parameter is the element-wise ratio\n         of the sample parameters of the arguments.\n       - `VectorizedDistribution / Number`: the result is a vectorized-distribution\n         whose sample parameter has been scaled down.\n\n    Warns:\n       - UserWarning: if computing `VectorizedDistribution / (VectorizedDistrion | Number)`\n         would result in a `x / 0` calculation, for any x.\n    \"\"\"\n    match other:\n        case VectorizedDistribution():\n            if (other.sample == 0).any():\n                warnings.warn(\n                    \"All entries in denominator array should be non-zero.\"\n                )\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample / other.sample, is_continuous=True\n            )\n        case float() | int():\n            if other == 0:\n                warnings.warn(\n                    \"Attempting to divide a vectorized distribution by zero.\"\n                )\n            return VectorizedDistribution(  # type: ignore\n                sample=self.sample / other, is_continuous=True\n            )\n        case _:\n            return NotImplemented\n</code></pre>"},{"location":"lognormal/","title":"lognormal","text":""},{"location":"normal/","title":"normal","text":""},{"location":"plotting/","title":"plotting","text":""},{"location":"poisson/","title":"poisson","text":""}]}