{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A python package that implements an easy-to-use interface for random variables, statistical distributions, and their algebra.</p> <p> </p> <p>This Python package is brought to you by Vaibhav Karve.</p> <p><code>distribution-algebra</code> recognizes Normal, Lognormal, Beta and Poisson distributions. The package implements an interface to easily construct user-defined Univariate distributions as well Vectorized distributions.</p> <p>Additional features include: - A <code>plot</code> function for probability density/mass function plotting. - A <code>draw</code> function for drawing random samples of specified size from   a given distribution. - Addition and multiplication operations defined directly on   distributions:   - For example, the sum of two Normal (Poisson) distributions is     Normal (Poisson).   - The product of two Lognormal distributions is Lognormal.   - The sum of two arbitrary univariate distributions is expressed as     a Vectorized distribution.</p> <p></p> <p>This package is written in Python v3.10, and is publicly available under the GNU-GPL-v3.0 license.</p>"},{"location":"#installation-and-usage","title":"Installation and usage","text":"<p>To get started on using this package,</p> <ol> <li>Install Python 3.10 or higher.</li> <li><code>python3.10 -m pip install distribution-algebra</code></li> <li>Use it in a python script (or interactive REPL)</li> </ol> Example showing addition of two Normal distributions<pre><code>from distribution_algebra import Normal  # (1)!\nx: Normal = Normal(mean=1.0, var=9.0)\ny: Normal = Normal(mean=1.0, var=16.0)\nassert x + y == Normal(mean=2.0, var=25.0)\n</code></pre> <ol> <li>You can similarly import other distributions as <code>from distribution_algebra import Normal, Beta, Lognormal, Beta4, Poisson</code>.</li> </ol>"},{"location":"__main__/","title":"main","text":""},{"location":"__main__/#mainpy","title":"main.py","text":""},{"location":"algebra/","title":"algebra","text":""},{"location":"algebra/#algebrapy","title":"algebra.py","text":""},{"location":"beta/","title":"beta","text":""},{"location":"beta/#betapy","title":"beta.py","text":""},{"location":"beta4/","title":"beta4","text":""},{"location":"beta4/#beta4py","title":"beta4.py","text":""},{"location":"config/","title":"config","text":""},{"location":"config/#configpy","title":"config.py","text":""},{"location":"distribution/","title":"distribution","text":""},{"location":"distribution/#distributionpy","title":"distribution.py","text":""},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution","title":"<code>VectorizedDistribution</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A Vectorized form of a probability distribution.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@dataclass(frozen=True, kw_only=True, eq=False, unsafe_hash=True)\nclass VectorizedDistribution(Algebra, Generic[T_in]):\n\"\"\"A Vectorized form of a probability distribution.\"\"\"\nsample: NDArray[T_in]\nis_continuous: bool = field(default=True, repr=False)\n@property\ndef mean(self) -&gt; np.float64:\nreturn np.float64(self.sample.mean())\n@property\ndef var(self) -&gt; np.float64:\nreturn np.float64(self.sample.var())\ndef __add__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample + other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample + other)\ncase _:\nreturn NotImplemented\ndef __mul__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample * other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample * other)\ncase _:\nreturn NotImplemented\ndef __sub__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample - other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample - other)\ncase _:\nreturn NotImplemented\ndef __pow__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif (other.sample == 0).any() and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**(other array) computation.\")\nreturn VectorizedDistribution(sample=self.sample ** other.sample)\ncase float() | int():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif not other and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**other computation.\")\nreturn VectorizedDistribution(sample=self.sample ** other)\ncase _:\nreturn NotImplemented\ndef __truediv__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nif (other.sample == 0).any():\nwarnings.warn(\"All entries in denominator array should be non-zero.\")\nreturn VectorizedDistribution(sample=self.sample / other.sample)\ncase float() | int():\nif other == 0:\nwarnings.warn(\"Attempting to divide a vectorized distribution by zero.\")\nreturn VectorizedDistribution(sample=self.sample / other)\ncase _:\nreturn NotImplemented\ndef __neg__(self) -&gt; Any:\nreturn VectorizedDistribution(sample=-self.sample)\n</code></pre>"},{"location":"lognormal/","title":"lognormal","text":""},{"location":"lognormal/#lognormalpy","title":"lognormal.py","text":""},{"location":"normal/","title":"normal","text":""},{"location":"normal/#normalpy","title":"normal.py","text":""},{"location":"plotting/","title":"plotting","text":""},{"location":"plotting/#plottingpy","title":"plotting.py","text":""},{"location":"poisson/","title":"poisson","text":""},{"location":"poisson/#poissonpy","title":"poisson.py","text":""}]}