{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A python package that implements an easy-to-use interface for random variables, statistical distributions, and their algebra.</p> <p> </p> <p>This Python package is brought to you by Vaibhav Karve.</p> <p><code>distribution-algebra</code> recognizes Normal, Lognormal, Beta and Poisson distributions. The package implements an interface to easily construct user-defined Univariate distributions as well Vectorized distributions.</p> <p>Additional features include: - A <code>plot</code> function for probability density/mass function plotting. - A <code>draw</code> function for drawing random samples of specified size from   a given distribution. - Addition and multiplication operations defined directly on   distributions:   - For example, the sum of two Normal (Poisson) distributions is     Normal (Poisson).   - The product of two Lognormal distributions is Lognormal.   - The sum of two arbitrary univariate distributions is expressed as     a Vectorized distribution.</p> <p></p> <p>This package is written in Python v3.10, and is available for installation from PyPI under the GNU-GPL-v3.0 license.</p>"},{"location":"#installation-and-usage","title":"Installation and usage","text":"<p>To get started on using this package,</p> <ol> <li>Install Python 3.10 or higher.</li> <li><code>python3.10 -m pip install distribution-algebra</code></li> <li>Use it in a python script (or interactive REPL)</li> </ol> Example showing addition of two Normal distributions<pre><code>from distribution_algebra import Normal  # (1)!\nx: Normal = Normal(mean=1.0, var=9.0)\ny: Normal = Normal(mean=1.0, var=16.0)\nassert x + y == Normal(mean=2.0, var=25.0)\n</code></pre> <ol> <li>You can similarly import other distributions as <code>from distribution_algebra import Normal, Beta, Lognormal, Beta4, Poisson</code>.</li> </ol>"},{"location":"__main__/","title":"main","text":""},{"location":"algebra/","title":"algebra","text":"<p>This module defines the commutative algebra structure of probability distributions.</p> <p>We define an <code>Algebra</code> class for enforcing the requisite structure via abstract-method definitions for left-operators. Right-operators for each left-operator is added on via <code>setattr</code> on the Algebra class (see function <code>define_right_operators_for_Algebra_class</code>).</p>"},{"location":"algebra/#distribution_algebra.algebra.Algebra","title":"Algebra","text":"<p>An abstract class for enforcing the definition of operations we care about.</p> <p>We specify left-operators as abstract methods in this class. Once the class is defined, we define the right-operators as being the swapped versions of their left-operators (see <code>Algebra_reverse_op</code> for details on how this is achieved).</p> Note <p>This class is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>class Algebra:\n\"\"\"An abstract class for enforcing the definition of operations we care about.\n    We specify left-operators as abstract methods in this class. Once\n    the class is defined, we define the right-operators as being the\n    swapped versions of their left-operators (see `Algebra_reverse_op`\n    for details on how this is achieved).\n    Note:\n       This class is for internal use only.\n    \"\"\"\n@abstractmethod\ndef __add__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-addition method.\"\"\"\n...\n@abstractmethod\ndef __sub__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-subtraction method.\"\"\"\n...\n@abstractmethod\ndef __mul__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-multiplication method.\"\"\"\n...\n@abstractmethod\ndef __truediv__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-division method.\"\"\"\n...\n@abstractmethod\ndef __pow__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n...\n@abstractmethod\ndef __neg__(self) -&gt; Any:\n\"\"\"An abstract negation (additive inverse) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__add__","title":"__add__  <code>abstractmethod</code>","text":"<pre><code>__add__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-addition method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-addition method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__mul__","title":"__mul__  <code>abstractmethod</code>","text":"<pre><code>__mul__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-multiplication method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __mul__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-multiplication method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__neg__","title":"__neg__  <code>abstractmethod</code>","text":"<pre><code>__neg__() -&gt; Any\n</code></pre> <p>An abstract negation (additive inverse) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __neg__(self) -&gt; Any:\n\"\"\"An abstract negation (additive inverse) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__pow__","title":"__pow__  <code>abstractmethod</code>","text":"<pre><code>__pow__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-power (or left-exponentiation) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __pow__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__sub__","title":"__sub__  <code>abstractmethod</code>","text":"<pre><code>__sub__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-subtraction method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-subtraction method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__truediv__","title":"__truediv__  <code>abstractmethod</code>","text":"<pre><code>__truediv__(other: Any) -&gt; Any\n</code></pre> <p>An abstract left-division method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __truediv__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-division method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra_reverse_op","title":"Algebra_reverse_op","text":"<pre><code>Algebra_reverse_op(op_name: str) -&gt; Callable[[Algebra, Any], Any]\n</code></pre> <p>Define the right-operator method, given a left-operator name in <code>op_name</code>.</p> Note <p>This function is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def Algebra_reverse_op(op_name: str) -&gt; Callable[[Algebra, Any], Any]:\n\"\"\"Define the right-operator method, given a left-operator name in `op_name`.\n    Note:\n       This function is for internal use only.\n    \"\"\"\ndef self_op_other(self: Algebra, other: Any) -&gt; Any:\n\"\"\"Reverse operation is just the operation acting on the arguments.\"\"\"\nreturn getattr(self, op_name)(other)\nreturn self_op_other\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.define_right_operators_for_Algebra_class","title":"define_right_operators_for_Algebra_class","text":"<pre><code>define_right_operators_for_Algebra_class() -&gt; None\n</code></pre> <p>Define a right-operator method for each of <code>Algebra</code>'s magic methods.</p> <p>We additionally mark each right-operator as being <code>final</code> in order to guard against a user over-riding them and possibly breaking symmetry with the left-operators.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def define_right_operators_for_Algebra_class() -&gt; None:\n\"\"\"Define a right-operator method for each of `Algebra`'s magic methods.\n    We additionally mark each right-operator as being `final` in order\n    to guard against a user over-riding them and possibly breaking\n    symmetry with the left-operators.\n    \"\"\"\nmagic_left_operator_methods: list[str] = [\n\"__add__\", \"__mul__\", \"__sub__\", \"__truediv__\", \"__pow__\"]\nfor magic_method in magic_left_operator_methods:\nright_operator_name: str = \"__r\" + magic_method.removeprefix(\"__\")\nsetattr(Algebra, right_operator_name, final(Algebra_reverse_op(magic_method)))\n</code></pre>"},{"location":"beta/","title":"beta","text":""},{"location":"beta4/","title":"beta4","text":""},{"location":"config/","title":"config","text":""},{"location":"distribution/","title":"distribution","text":"<p>This module defines abstract classes for statistical distributions.</p> <p>We define 2 types of distributions. The first is <code>UnivariateDistribution</code>. Most named statistical distributions we learn about in a statistics course (Normal, Beta, Uniform, etc.) can be thought of as instances of <code>UnivariateDistribution</code>.</p> <p>Second, we define a statistical distribution whose parameter might not be known. Such a distribution is tracked by keeping around a really large sample. We name this a <code>VectorizedDistribution</code>. In many cases, working with vectorized distributions is easier since it allows us to apply algebraic operations to them.</p>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution","title":"UnivariateDistribution","text":"<p>         Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A univariate probability distribution.</p> <p>All named distributions defined in this library are subclasses of <code>UnivariateDistribution</code>. This class can also be used by a user for defining new distributions (as subclasses) but beware that the class mandates lots of properties and methods be defined for each concrete subclass.</p> <p>Parameters:</p> Name Type Description Default <code>is_continuous</code> <p>used to track if the distribution is continuous or discrete.</p> required Implementation details <ul> <li>If <code>is_continuous</code> is set to True, then <code>T_in</code> should be a \"continuous\" type like   <code>float</code> or <code>numpy.float64</code>. If it is set to False, then <code>T_in</code> should be a discrete   type like <code>int</code> or <code>numpy.int64</code>.</li> <li>We set <code>frozen=True</code> to enforce immutability of each subclass and each instance of   this class.</li> <li>We set <code>unsafe_hash=True</code> to make this class hashable (it is immutable   after all).</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@attr.frozen(kw_only=True)\nclass UnivariateDistribution(Algebra, Generic[T_in]):\n\"\"\"A univariate probability distribution.\n    All named distributions defined in this library are subclasses of\n    `UnivariateDistribution`. This class can also be used by a user for defining new\n    distributions (as subclasses) but beware that the class mandates\n    lots of properties and methods be defined for each concrete subclass.\n    Params:\n       is_continuous: used to track if the distribution is continuous or discrete.\n    Other Params: Implementation details\n       * If `is_continuous` is set to True, then `T_in` should be a \"continuous\" type like\n         `float` or `numpy.float64`. If it is set to False, then `T_in` should be a discrete\n         type like `int` or `numpy.int64`.\n       * We set `frozen=True` to enforce immutability of each subclass and each instance of\n         this class.\n       * We set `unsafe_hash=True` to make this class hashable (it is immutable\n         after all).\n    \"\"\"\n@property\ndef is_continuous(self) -&gt; bool:\nT_in_at_runtime: type = get_args(self.__orig_bases__[0])[0]\nmatch T_in_at_runtime:\ncase np.int_ | np.int64:\nreturn False\ncase np.float64:\nreturn True\ncase _:\nraise TypeError(f\"Found unsupported type {T_in_at_runtime}\")\n@property\n@abstractmethod\ndef median(self) -&gt; float: ...\n@property\n@abstractmethod\ndef mode(self) -&gt; float: ...\n@property\n@abstractmethod\ndef support(self) -&gt; tuple[float, float]: ...\n@abstractmethod\ndef draw(self, size: int) -&gt; NDArray[T_in]: ...\ndef to_vectorized(self) -&gt; VectorizedDistribution[T_in]:\n\"\"\"In most cases, if using  `(x: UnivariateDistribution).to_vectorized()`\n        to create a `VectorizedDistribution` instance, the instance's `is_continuous`\n        parameter is equal to `x.is_continuous`. In other words, continuous\n        (discrete) univariate distributions give rise to continuous (discrete)\n        vectorized distributions.\"\"\"\nreturn VectorizedDistribution(  # type: ignore\nsample=self.draw(size=SAMPLE_SIZE),\nis_continuous=self.is_continuous)\n@abstractmethod\ndef pdf(self, linspace: NDArray[np.float64] | NDArray[np.int64]) -&gt; NDArray[np.float64]: ...\ndef __add__(self, other: Any) -&gt; Any:\nmatch other:\ncase UnivariateDistribution():\nreturn self.to_vectorized() + other.to_vectorized()\ncase _:\nreturn self.to_vectorized() + other\ndef __mul__(self, other: Any) -&gt; Any:\nmatch other:\ncase UnivariateDistribution():\nreturn self.to_vectorized() * other.to_vectorized()\ncase _:\nreturn self.to_vectorized() * other\ndef __sub__(self, other: Any) -&gt; Any:\nmatch other:\ncase UnivariateDistribution():\nreturn self.to_vectorized() - other.to_vectorized()\ncase _:\nreturn self.to_vectorized() - other\ndef __truediv__(self, other: Any) -&gt; Any:\nmatch other:\ncase UnivariateDistribution():\nreturn self.to_vectorized() / other.to_vectorized()\ncase _:\nreturn self.to_vectorized() / other\ndef __pow__(self, other: Any) -&gt; Any:\nmatch other:\ncase UnivariateDistribution():\nreturn self.to_vectorized() ** other.to_vectorized()\ncase _:\nreturn self.to_vectorized() ** other\ndef __neg__(self) -&gt; Any:\nreturn -self.to_vectorized()\ndef __repr__(self) -&gt; str:\nreturn f\"{self.__class__.__name__}({vars(self)})\"\ndef __eq__(self, other: Any) -&gt; bool:\nmatch other:\ncase UnivariateDistribution():\nif not isinstance(other, type(self)):\nreturn False\nif not vars(self).keys() == vars(other).keys():\nreturn False\nreturn all(isclose(value, vars(other)[field], abs_tol=ABS_TOL)\nfor field, value in vars(self).items())\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.UnivariateDistribution.to_vectorized","title":"to_vectorized","text":"<pre><code>to_vectorized() -&gt; VectorizedDistribution[T_in]\n</code></pre> <p>In most cases, if using  <code>(x: UnivariateDistribution).to_vectorized()</code> to create a <code>VectorizedDistribution</code> instance, the instance's <code>is_continuous</code> parameter is equal to <code>x.is_continuous</code>. In other words, continuous (discrete) univariate distributions give rise to continuous (discrete) vectorized distributions.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def to_vectorized(self) -&gt; VectorizedDistribution[T_in]:\n\"\"\"In most cases, if using  `(x: UnivariateDistribution).to_vectorized()`\n    to create a `VectorizedDistribution` instance, the instance's `is_continuous`\n    parameter is equal to `x.is_continuous`. In other words, continuous\n    (discrete) univariate distributions give rise to continuous (discrete)\n    vectorized distributions.\"\"\"\nreturn VectorizedDistribution(  # type: ignore\nsample=self.draw(size=SAMPLE_SIZE),\nis_continuous=self.is_continuous)\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution","title":"VectorizedDistribution","text":"<p>         Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A Vectorized form of a probability distribution.</p> <p>Parameters:</p> Name Type Description Default <code>sample</code> <p>the sample-vector used in lieu of a closed-form expression for the distribution.</p> required <code>is_continuous</code> <p>used to track if the distribution is continuous or discrete.</p> required Implementation details <ul> <li>We use <code>attr.frozen</code> in this definition because it supports validation and   immutability.</li> <li>We use <code>attr.frozen</code> to enforce immutability of each instance of this class.   To modify the class or its sample-attribute, the user must define a new   instance (or use <code>attr.evolve</code>) instead of modifying an existing one.</li> <li><code>sample</code> is chosen to be a numpy array to leverage the fast, vectorized   operations enabled by numpy's C API.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@attr.frozen(kw_only=True)\nclass VectorizedDistribution(Algebra, Generic[T_in]):\n\"\"\"A Vectorized form of a probability distribution.\n    Params:\n       sample: the sample-vector used in lieu of a closed-form expression for\n          the distribution.\n       is_continuous: used to track if the distribution is continuous or discrete.\n    Other Params: Implementation details\n       * We use `attr.frozen` in this definition because it supports validation and\n         immutability.\n       * We use `attr.frozen` to enforce immutability of each instance of this class.\n         To modify the class or its sample-attribute, the user must define a new\n         instance (or use `attr.evolve`) instead of modifying an existing one.\n       * `sample` is chosen to be a numpy array to leverage the fast, vectorized\n         operations enabled by numpy's C API.\n    \"\"\"\nsample: NDArray[T_in] = attr.field(eq=attr.cmp_using(eq=np.array_equal))  # type: ignore\nis_continuous: bool = attr.field(repr=False)\n@is_continuous.validator  # type: ignore\ndef check_is_continuous(self, _: Literal[\"is_continuous\"], is_continuous_value: bool) -&gt; None:\nmatch self.sample.dtype:\ncase np.int64:\nassert not is_continuous_value\ncase np.float64:\nassert is_continuous_value\ncase _:\nraise TypeError(f\"Encountered unknown type {self.sample.dtype} in VectorizedDistribution.\")\n@property\ndef mean(self) -&gt; np.float64:\n\"\"\"Mean of the distribution, defined as the mean of the sample.\n        Returns:\n           mean of the distribution, defined as the mean of the sample.\n        \"\"\"\nreturn np.float64(self.sample.mean())\n@property\ndef var(self) -&gt; np.float64:\n\"\"\"Variance of the distribution, defined as the variance of the sample.\n        Returns:\n           variance of the distribution, defined as the variance of the sample.\n        \"\"\"\nreturn np.float64(self.sample.var())\ndef __add__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-sum of a VectorDistribution with any other type.\n        Types:\n           - `VectorizedDistribution + VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise sum\n             of the sample parameters of the summands.\n           - `VectorizedDistribution + Number`: the result is a vectorized-distribution\n             whose sample values have been shifted.\n        \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample + other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(\nsample=self.sample + other,  # type: ignore\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\ndef __mul__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-product of a VectorDistribution with any other type.\n        Types:\n           - `VectorizedDistribution * VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise product\n             of the sample parameters of the multiplicands.\n           - `VectorizedDistribution * Number`: the result is a vectorized-distribution\n             whose sample values have been scaled.\n        \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample * other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample * other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\ndef __sub__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-difference of a VectorDistribution with any other type.\n        Types:\n           - `VectorizedDistribution - VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose samples parameter is the element-wise difference\n             of the sample parameters of the arguments.\n           - `VectorizedDistribution - Number`: the result is a vectorized-distribution\n             whose sample values have been shifted.\n        \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample - other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample - other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\ndef __pow__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-power of a VectorDistribution with any other type.\n        Types:\n           - `VectorizedDistribution ** VectorizedDistribution`: the result is also a\n             vectorized-distrubution. Result's i'th sample entry is\n             `self.sample[i] ** other.sample[i]`.\n           - `VectorizedDistribution - Number`: the result is a vectorized-distribution.\n             Result's i'th sample entry is `self.sample[i] ** other`.\n        Warns:\n           - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistrion | Number)`\n             would result in raising a negative number to any power.\n           - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistribution | Number)`\n             would result in a `0 ** 0` computation.\n        \"\"\"\nmatch other:\ncase VectorizedDistribution():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif (other.sample == 0).any() and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**(other array) computation.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample ** other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif not other and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**other computation.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample ** other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\ndef __truediv__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-division of a VectorDistribution with any other type.\n        Types:\n           - `VectorizedDistribution / VectorizedDistribution`: the result is also a\n             vectorized-distrubution whose sample parameter is the element-wise ratio\n             of the sample parameters of the arguments.\n           - `VectorizedDistribution / Number`: the result is a vectorized-distribution\n             whose sample parameter has been scaled down.\n        Warns:\n           - UserWarning: if computing `VectorizedDistribution / (VectorizedDistrion | Number)`\n             would result in a `x / 0` calculation, for any x.\n        \"\"\"\nmatch other:\ncase VectorizedDistribution():\nif (other.sample == 0).any():\nwarnings.warn(\"All entries in denominator array should be non-zero.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample / other.sample,\nis_continuous=True)\ncase float() | int():\nif other == 0:\nwarnings.warn(\"Attempting to divide a vectorized distribution by zero.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample / other,\nis_continuous=True)\ncase _:\nreturn NotImplemented\ndef __neg__(self) -&gt; Any:\n\"\"\"Return the negative of a VectorizedDistribution.\n        Returns:\n           (VectorizedDistribution): A VectorizedDistribution whose sample entries are the\n              negative of the original's.\n        \"\"\"\nreturn VectorizedDistribution(sample=-self.sample, is_continuous=self.is_continuous)  # type: ignore\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.mean","title":"mean  <code>property</code>","text":"<pre><code>mean: np.float64\n</code></pre> <p>Mean of the distribution, defined as the mean of the sample.</p> <p>Returns:</p> Type Description <code>np.float64</code> <p>mean of the distribution, defined as the mean of the sample.</p>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.var","title":"var  <code>property</code>","text":"<pre><code>var: np.float64\n</code></pre> <p>Variance of the distribution, defined as the variance of the sample.</p> <p>Returns:</p> Type Description <code>np.float64</code> <p>variance of the distribution, defined as the variance of the sample.</p>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__add__","title":"__add__","text":"<pre><code>__add__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-sum of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution + VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise sum   of the sample parameters of the summands.</li> <li><code>VectorizedDistribution + Number</code>: the result is a vectorized-distribution   whose sample values have been shifted.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __add__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-sum of a VectorDistribution with any other type.\n    Types:\n       - `VectorizedDistribution + VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise sum\n         of the sample parameters of the summands.\n       - `VectorizedDistribution + Number`: the result is a vectorized-distribution\n         whose sample values have been shifted.\n    \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample + other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(\nsample=self.sample + other,  # type: ignore\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-product of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution * VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise product   of the sample parameters of the multiplicands.</li> <li><code>VectorizedDistribution * Number</code>: the result is a vectorized-distribution   whose sample values have been scaled.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __mul__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-product of a VectorDistribution with any other type.\n    Types:\n       - `VectorizedDistribution * VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise product\n         of the sample parameters of the multiplicands.\n       - `VectorizedDistribution * Number`: the result is a vectorized-distribution\n         whose sample values have been scaled.\n    \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample * other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample * other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Any\n</code></pre> <p>Return the negative of a VectorizedDistribution.</p> <p>Returns:</p> Type Description <code>VectorizedDistribution</code> <p>A VectorizedDistribution whose sample entries are the negative of the original's.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __neg__(self) -&gt; Any:\n\"\"\"Return the negative of a VectorizedDistribution.\n    Returns:\n       (VectorizedDistribution): A VectorizedDistribution whose sample entries are the\n          negative of the original's.\n    \"\"\"\nreturn VectorizedDistribution(sample=-self.sample, is_continuous=self.is_continuous)  # type: ignore\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-power of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution ** VectorizedDistribution</code>: the result is also a   vectorized-distrubution. Result's i'th sample entry is   <code>self.sample[i] ** other.sample[i]</code>.</li> <li><code>VectorizedDistribution - Number</code>: the result is a vectorized-distribution.   Result's i'th sample entry is <code>self.sample[i] ** other</code>.</li> </ul> Warns <ul> <li>UserWarning: if computing <code>VectorizedDistribution ** (VectorizedDistrion | Number)</code>   would result in raising a negative number to any power.</li> <li>UserWarning: if computing <code>VectorizedDistribution ** (VectorizedDistribution | Number)</code>   would result in a <code>0 ** 0</code> computation.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __pow__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-power of a VectorDistribution with any other type.\n    Types:\n       - `VectorizedDistribution ** VectorizedDistribution`: the result is also a\n         vectorized-distrubution. Result's i'th sample entry is\n         `self.sample[i] ** other.sample[i]`.\n       - `VectorizedDistribution - Number`: the result is a vectorized-distribution.\n         Result's i'th sample entry is `self.sample[i] ** other`.\n    Warns:\n       - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistrion | Number)`\n         would result in raising a negative number to any power.\n       - UserWarning: if computing `VectorizedDistribution ** (VectorizedDistribution | Number)`\n         would result in a `0 ** 0` computation.\n    \"\"\"\nmatch other:\ncase VectorizedDistribution():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif (other.sample == 0).any() and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**(other array) computation.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample ** other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif not other and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**other computation.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample ** other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-difference of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution - VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose samples parameter is the element-wise difference   of the sample parameters of the arguments.</li> <li><code>VectorizedDistribution - Number</code>: the result is a vectorized-distribution   whose sample values have been shifted.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __sub__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-difference of a VectorDistribution with any other type.\n    Types:\n       - `VectorizedDistribution - VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose samples parameter is the element-wise difference\n         of the sample parameters of the arguments.\n       - `VectorizedDistribution - Number`: the result is a vectorized-distribution\n         whose sample values have been shifted.\n    \"\"\"\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample - other.sample,\nis_continuous=self.is_continuous or other.is_continuous)\ncase float() | int():\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample - other,\nis_continuous=self.is_continuous or isinstance(other, float))\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: Any) -&gt; Any\n</code></pre> <p>Return the left-division of a VectorDistribution with any other type.</p> Types <ul> <li><code>VectorizedDistribution / VectorizedDistribution</code>: the result is also a   vectorized-distrubution whose sample parameter is the element-wise ratio   of the sample parameters of the arguments.</li> <li><code>VectorizedDistribution / Number</code>: the result is a vectorized-distribution   whose sample parameter has been scaled down.</li> </ul> Warns <ul> <li>UserWarning: if computing <code>VectorizedDistribution / (VectorizedDistrion | Number)</code>   would result in a <code>x / 0</code> calculation, for any x.</li> </ul> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>def __truediv__(self, other: Any) -&gt; Any:\n\"\"\"Return the left-division of a VectorDistribution with any other type.\n    Types:\n       - `VectorizedDistribution / VectorizedDistribution`: the result is also a\n         vectorized-distrubution whose sample parameter is the element-wise ratio\n         of the sample parameters of the arguments.\n       - `VectorizedDistribution / Number`: the result is a vectorized-distribution\n         whose sample parameter has been scaled down.\n    Warns:\n       - UserWarning: if computing `VectorizedDistribution / (VectorizedDistrion | Number)`\n         would result in a `x / 0` calculation, for any x.\n    \"\"\"\nmatch other:\ncase VectorizedDistribution():\nif (other.sample == 0).any():\nwarnings.warn(\"All entries in denominator array should be non-zero.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample / other.sample,\nis_continuous=True)\ncase float() | int():\nif other == 0:\nwarnings.warn(\"Attempting to divide a vectorized distribution by zero.\")\nreturn VectorizedDistribution(  # type: ignore\nsample=self.sample / other,\nis_continuous=True)\ncase _:\nreturn NotImplemented\n</code></pre>"},{"location":"lognormal/","title":"lognormal","text":""},{"location":"normal/","title":"normal","text":""},{"location":"plotting/","title":"plotting","text":""},{"location":"poisson/","title":"poisson","text":""}]}