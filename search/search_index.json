{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A python package that implements an easy-to-use interface for random variables, statistical distributions, and their algebra.</p> <p> </p> <p>This Python package is brought to you by Vaibhav Karve.</p> <p><code>distribution-algebra</code> recognizes Normal, Lognormal, Beta and Poisson distributions. The package implements an interface to easily construct user-defined Univariate distributions as well Vectorized distributions.</p> <p>Additional features include: - A <code>plot</code> function for probability density/mass function plotting. - A <code>draw</code> function for drawing random samples of specified size from   a given distribution. - Addition and multiplication operations defined directly on   distributions:   - For example, the sum of two Normal (Poisson) distributions is     Normal (Poisson).   - The product of two Lognormal distributions is Lognormal.   - The sum of two arbitrary univariate distributions is expressed as     a Vectorized distribution.</p> <p></p> <p>This package is written in Python v3.10, and is available for installation from PyPI under the GNU-GPL-v3.0 license.</p>"},{"location":"#installation-and-usage","title":"Installation and usage","text":"<p>To get started on using this package,</p> <ol> <li>Install Python 3.10 or higher.</li> <li><code>python3.10 -m pip install distribution-algebra</code></li> <li>Use it in a python script (or interactive REPL)</li> </ol> Example showing addition of two Normal distributions<pre><code>from distribution_algebra import Normal  # (1)!\nx: Normal = Normal(mean=1.0, var=9.0)\ny: Normal = Normal(mean=1.0, var=16.0)\nassert x + y == Normal(mean=2.0, var=25.0)\n</code></pre> <ol> <li>You can similarly import other distributions as <code>from distribution_algebra import Normal, Beta, Lognormal, Beta4, Poisson</code>.</li> </ol>"},{"location":"__main__/","title":"main","text":""},{"location":"algebra/","title":"algebra","text":"<p>This module defines the commutative algebra structure of probability distributions.</p> <p>We define an <code>Algebra</code> class for enforcing the requisite structure via abstract-method definitions for left-operators. Right-operators for each left-operator is added on via <code>setattr</code> on the Algebra class (see function <code>define_right_operators_for_Algebra_class</code>).</p>"},{"location":"algebra/#distribution_algebra.algebra.Algebra","title":"<code>Algebra</code>","text":"<p>An abstract class for enforcing the definition of operations we care about.</p> <p>We specify left-operators as abstract methods in this class. Once the class is defined, we define the right-operators as being the swapped versions of their left-operators (see <code>Algebra_reverse_op</code> for details on how this is achieved).</p> Note <p>This class is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>class Algebra:\n\"\"\"An abstract class for enforcing the definition of operations we care about.\n    We specify left-operators as abstract methods in this class. Once\n    the class is defined, we define the right-operators as being the\n    swapped versions of their left-operators (see `Algebra_reverse_op`\n    for details on how this is achieved).\n    Note:\n       This class is for internal use only.\n    \"\"\"\n@abstractmethod\ndef __add__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-addition method.\"\"\"\n...\n@abstractmethod\ndef __sub__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-subtraction method.\"\"\"\n...\n@abstractmethod\ndef __mul__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-multiplication method.\"\"\"\n...\n@abstractmethod\ndef __truediv__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-division method.\"\"\"\n...\n@abstractmethod\ndef __pow__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n...\n@abstractmethod\ndef __neg__(self) -&gt; Any:\n\"\"\"An abstract negation (additive inverse) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__add__","title":"<code>__add__(other)</code>  <code>abstractmethod</code>","text":"<p>An abstract left-addition method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-addition method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__mul__","title":"<code>__mul__(other)</code>  <code>abstractmethod</code>","text":"<p>An abstract left-multiplication method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __mul__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-multiplication method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__neg__","title":"<code>__neg__()</code>  <code>abstractmethod</code>","text":"<p>An abstract negation (additive inverse) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __neg__(self) -&gt; Any:\n\"\"\"An abstract negation (additive inverse) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__pow__","title":"<code>__pow__(other)</code>  <code>abstractmethod</code>","text":"<p>An abstract left-power (or left-exponentiation) method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __pow__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-power (or left-exponentiation) method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__sub__","title":"<code>__sub__(other)</code>  <code>abstractmethod</code>","text":"<p>An abstract left-subtraction method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-subtraction method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra.__truediv__","title":"<code>__truediv__(other)</code>  <code>abstractmethod</code>","text":"<p>An abstract left-division method.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>@abstractmethod\ndef __truediv__(self, other: Any) -&gt; Any:\n\"\"\"An abstract left-division method.\"\"\"\n...\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.Algebra_reverse_op","title":"<code>Algebra_reverse_op(op_name)</code>","text":"<p>Define the right-operator method, given a left-operator name in <code>op_name</code>.</p> Note <p>This function is for internal use only.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def Algebra_reverse_op(op_name: str) -&gt; Callable[[Algebra, Any], Any]:\n\"\"\"Define the right-operator method, given a left-operator name in `op_name`.\n    Note:\n       This function is for internal use only.\n    \"\"\"\ndef self_op_other(self: Algebra, other: Any) -&gt; Any:\n\"\"\"Reverse operation is just the operation acting on the arguments.\"\"\"\nreturn getattr(self, op_name)(other)\nreturn self_op_other\n</code></pre>"},{"location":"algebra/#distribution_algebra.algebra.define_right_operators_for_Algebra_class","title":"<code>define_right_operators_for_Algebra_class()</code>","text":"<p>Define a right-operator method for each of <code>Algebra</code>'s magic methods.</p> <p>We additionally mark each right-operator as being <code>final</code> in order to guard against a user over-riding them and possibly breaking symmetry with the left-operators.</p> Source code in <code>distribution_algebra/algebra.py</code> <pre><code>def define_right_operators_for_Algebra_class() -&gt; None:\n\"\"\"Define a right-operator method for each of `Algebra`'s magic methods.\n    We additionally mark each right-operator as being `final` in order\n    to guard against a user over-riding them and possibly breaking\n    symmetry with the left-operators.\n    \"\"\"\nmagic_left_operator_methods: list[str] = [\n\"__add__\", \"__mul__\", \"__sub__\", \"__truediv__\", \"__pow__\"]\nfor magic_method in magic_left_operator_methods:\nright_operator_name: str = \"__r\" + magic_method.removeprefix(\"__\")\nsetattr(Algebra, right_operator_name, final(Algebra_reverse_op(magic_method)))\n</code></pre>"},{"location":"beta/","title":"beta","text":""},{"location":"beta4/","title":"beta4","text":""},{"location":"config/","title":"config","text":""},{"location":"distribution/","title":"distribution","text":""},{"location":"distribution/#distribution_algebra.distribution.VectorizedDistribution","title":"<code>VectorizedDistribution</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Algebra</code>, <code>Generic[T_in]</code></p> <p>A Vectorized form of a probability distribution.</p> Source code in <code>distribution_algebra/distribution.py</code> <pre><code>@dataclass(frozen=True, kw_only=True, eq=False, unsafe_hash=True)\nclass VectorizedDistribution(Algebra, Generic[T_in]):\n\"\"\"A Vectorized form of a probability distribution.\"\"\"\nsample: NDArray[T_in]\nis_continuous: bool = field(default=True, repr=False)\n@property\ndef mean(self) -&gt; np.float64:\nreturn np.float64(self.sample.mean())\n@property\ndef var(self) -&gt; np.float64:\nreturn np.float64(self.sample.var())\ndef __add__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample + other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample + other)\ncase _:\nreturn NotImplemented\ndef __mul__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample * other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample * other)\ncase _:\nreturn NotImplemented\ndef __sub__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nreturn VectorizedDistribution(sample=self.sample - other.sample)\ncase float() | int():\nreturn VectorizedDistribution(sample=self.sample - other)\ncase _:\nreturn NotImplemented\ndef __pow__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif (other.sample == 0).any() and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**(other array) computation.\")\nreturn VectorizedDistribution(sample=self.sample ** other.sample)\ncase float() | int():\nif (self.sample &lt; 0).any():\nwarnings.warn(\"All entries in base array should be positive.\")\nif not other and (self.sample == 0).any():\nwarnings.warn(\"Attempting to compute 0**0 during (base array)**other computation.\")\nreturn VectorizedDistribution(sample=self.sample ** other)\ncase _:\nreturn NotImplemented\ndef __truediv__(self, other: Any) -&gt; Any:\nmatch other:\ncase VectorizedDistribution():\nif (other.sample == 0).any():\nwarnings.warn(\"All entries in denominator array should be non-zero.\")\nreturn VectorizedDistribution(sample=self.sample / other.sample)\ncase float() | int():\nif other == 0:\nwarnings.warn(\"Attempting to divide a vectorized distribution by zero.\")\nreturn VectorizedDistribution(sample=self.sample / other)\ncase _:\nreturn NotImplemented\ndef __neg__(self) -&gt; Any:\nreturn VectorizedDistribution(sample=-self.sample)\n</code></pre>"},{"location":"lognormal/","title":"lognormal","text":""},{"location":"normal/","title":"normal","text":""},{"location":"plotting/","title":"plotting","text":""},{"location":"poisson/","title":"poisson","text":""}]}